# algorithm_js

# 📝 알고리즘 문제 풀이 - 2025-07-20

## 문제 📖

- **문제 링크:** [프로그래머스 - 숫자 변환하기](https://school.programmers.co.kr/learn/courses/30/lessons/154538)

- **문제 유형:** `BFS`

- **난이도:** LEVEL 2

- **풀이 시간:** ⏳ 2시간 - 실제 걸렸던 시간

## 밍고에 강의

DFS와 함께 그래프 탐색에서 자주 나오는 BFS 유형 문제.

DFS는 완전 탐색이 컨셉이라면, BFS는 "최소 탐색"이 컨셉이다.
DFS가 한 가지 경우 모두 이동하며 탐색 -> 다음 경우 모두 이동하며 탐색 -> ... 이런 순이라면,
BFS는 1번 이동한 경우 모두 탐색 -> 2번 이동한 경우 모두 탐색 -> ... 라서, 최소 번째 탐색을 찾을 때 유용하다.
이 문제에서도 최소 연산 횟수를 요구하고 있기 때문에, BFS 접근이 적합하다.

BFS는 자료 구조 중 큐를 이용하는데, 문제는 큐가 스택과 달리 코테 자바스크립트 환경에서 지원해주는 라이브러리가 없다는 것이다.
따라서 시간 복잡도 상 이득을 보기 위해선, 큐를 직접 구현해야 된다.
연결 리스트를 이용해 구현하는 게 가장 정석이지만, 코드가 너무 길어서 야매로 배열을 이용해 큐를 구현했다.
이렇게 구현하면 값이 실제로 빠지진 않고 참조하는 index만 달라지는 거라서, 메모리를 많이 잡아먹는 단점이 있다.

## ✍ 접근 방식

1. BFS를 구현하기 위해서 큐를 클래스로 구현한다.
2. 정답을 -1로 초기화한다.
3. 초기값을 선언하고 [처음 값,0(연산 카운트)]를 설정한다.
4. 방문을 한 숫자인지를 알기 위해서 visited 배열을 초기화한다.
5. 큐가 전부 비울 때까지 반복을 한다.
6. 큐에 있는 앞에 있는 값을 꺼낸다.
7. X의 값이 도달하려는 숫자보다 클 경우, 이미 방문한 숫자인 경우는 넘어간다.
8. X와 y의 값이 같은 경우 최소 연산 숫자이므로 정답에 할당한 후 while문을 종료시킨다.
9. 만약 같지 않은 경우 해당 숫자를 방문했다고 표시한다.
10. 다음 탐색할 수 있는 경우의 수를 queue에 넣어주고 연산 카운트를 + 1 해준다.
